from django.contrib import admin
from django import forms
from django.db.models import F, DurationField, ExpressionWrapper
from django.db.models.functions import Coalesce
from django.utils.html import format_html
from django.utils import timezone
from datetime import timedelta
from django.core.exceptions import ValidationError

from competitions.models import (
    Tournament, Stage, Series, Game,
    TeamGameStat, PlayerGameStat, GameDraftAction, TournamentTeam
)
from teams.models import Team
from players.models import Player
from heroes.models import Hero


# ---------- Inlines ----------

class StageInline(admin.TabularInline):
    model = Stage
    extra = 0
    fields = ("stage_type", "variant", "order", "tier", "start_date", "end_date")
    ordering = ("order",)
    show_change_link = True
    

class TeamGameStatInline(admin.TabularInline):
    model = TeamGameStat
    extra = 0
    autocomplete_fields = ("team",)
    fields = ("team", "k", "d", "a", "gold", "turret_destroyed", "lord_kills", "turtle_kills", "game_win")
    readonly_fields = ("gold",)
    ordering = ("team__short_name",)


class PlayerGameStatInline(admin.TabularInline):
    model = PlayerGameStat
    extra = 0
    autocomplete_fields = ("player", "hero")
    fields = (
        "player", "team", "hero",
        "k", "d", "a",
        "gold", "dmg_dealt", "dmg_taken"
    )
    ordering = ("player__ign",)


class GameDraftActionInline(admin.TabularInline):
    model = GameDraftAction
    extra = 0
    autocomplete_fields = ("player", "hero")
    fields = ("order", "side", "action", "hero", "player", "team")
    ordering = ("order",)

class TournamentTeamInline(admin.TabularInline):
    model = TournamentTeam
    extra = 0
    autocomplete_fields = ("team",)
    fields = ("team", "seed", "kind", "group", "notes")
    ordering = ("seed", "team__short_name")


# ---------- Admins ----------

@admin.register(Tournament)
class TournamentAdmin(admin.ModelAdmin):
    list_display = ("logo_thumb", "name", "region", "team_count", "tier", "status", "start_date", "end_date")
    list_filter = ("region", "tier", "status", "start_date")
    search_fields = ("name", "slug")
    prepopulated_fields = {"slug": ("name",)}
    ordering = ("-start_date", "name")
    readonly_fields = ("logo_preview", "status", "created_at", "updated_at")
    inlines = [StageInline, TournamentTeamInline]

    fieldsets = (
        (None, {"fields": ("name", "slug", "region", "tier", "status")}),
        ("Schedule", {"fields": ("start_date", "end_date")}),
        ("Branding", {"fields": ("logo", "logo_preview")}),
        ("Timestamps", {"classes": ("collapse",), "fields": ("created_at", "updated_at")}),
    )

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.only("id", "name", "slug", "region", "tier", "status", "start_date", "end_date", "logo")

    @admin.display(description="Logo")
    def logo_thumb(self, obj: Tournament):
        if getattr(obj, "logo", None):
            return format_html('<img src="{}" style="height:28px;width:28px;border-radius:4px;object-fit:cover;" />', obj.logo.url)
        return "—"

    @admin.display(description="Logo Preview")
    def logo_preview(self, obj: Tournament):
        if getattr(obj, "logo", None):
            return format_html('<img src="{}" style="max-height:120px;border-radius:8px;" />', obj.logo.url)
        return "No logo"
    
    @admin.display(description="Number of Teams")
    def team_count(self, obj: Tournament):
        return obj.teams.count()

@admin.display(description="Stage")
def stage_title(obj: Stage):
    type_label = dict(Stage.STAGE_TYPES).get(obj.stage_type, obj.stage_type)
    return f'{type_label}{f" - {obj.variant}" if obj.variant else ""}'

@admin.register(Stage)
class StageAdmin(admin.ModelAdmin):
    list_display = ("stage_type", "variant", "tournament", "order", "status", "start_date", "end_date")
    list_filter = ("tournament",)
    search_fields = ("stage_type", "variant", "tournament__name",)
    prepopulated_fields = {"slug": ("stage_type", "variant")}
    ordering = ("tournament__start_date", "order")
    autocomplete_fields = ("tournament",)
    readonly_fields = ("status", "created_at", "updated_at")
    fieldsets = (
        (None, {"fields": ("tournament", "stage_type", "variant", "slug", "order", "tier")}),
        ("Schedule", {"fields": ("start_date", "end_date")}),
        ("Timestamps", {"classes": ("collapse",), "fields": ("status", "created_at", "updated_at")}),
    )

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.select_related("tournament")


# ----- Series: limit Stage/Teams to the selected Tournament -----

class SeriesAdminForm(forms.ModelForm):
    class Meta:
        model = Series
        fields = "__all__"

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        tournament = self.instance.tournament if self.instance and self.instance.pk else self.initial.get("tournament")
        # If creating (no instance yet), try to read tournament from POST or GET
        if not tournament:
            data = self.data or None
            if data and data.get("tournament"):
                try:
                    tournament = Tournament.objects.get(pk=data.get("tournament"))
                except Tournament.DoesNotExist:
                    tournament = None

        # Scope the Stage dropdown to this tournament
        if tournament and "stage" in self.fields:
            self.fields["stage"].queryset = Stage.objects.filter(tournament=tournament).order_by("order")

        # Scope team1/team2 to tournament-registered teams if you maintain M2M; else leave all teams
        if tournament and hasattr(tournament, "teams"):
            t_teams = tournament.teams.all()
            if "team1" in self.fields:
                self.fields["team1"].queryset = t_teams
            if "team2" in self.fields:
                self.fields["team2"].queryset = t_teams


@admin.register(Series)
class SeriesAdmin(admin.ModelAdmin):
    form = SeriesAdminForm
    list_display = ("series_matchup", "stage", "score", "winner", "best_of", "scheduled_date")
    list_filter = ("tournament", "stage", "best_of")
    search_fields = (
        "tournament__name", "tournament__short_name",
        "team1__name", "team1__short_name", "team2__name", "team2__short_name"
    )
    ordering = ("-scheduled_date",)
    autocomplete_fields = ("tournament", "stage", "team1", "team2", "winner")
    readonly_fields = ("score", "winner", "created_at", "updated_at")
    fieldsets = (
        (None, {"fields": ("tournament", "stage", "team1", "team2", "best_of", "scheduled_date")}),
        ("Results", {"fields": ("score", "winner")}),
        ("Timestamps", {"classes": ("collapse",), "fields": ("created_at", "updated_at")}),
    )

    @admin.display(description="Series Matchup")
    def series_matchup(self, obj):
        return f"{obj.team1} vs {obj.team2}"
    
    @admin.display(description="Score")
    def score(self, obj):
        if obj.team1_score is not None and obj.team2_score is not None:
            return f"{obj.team1_score} - {obj.team2_score}"
        return "—"
    
    # Display team_short_name for winner
    @admin.display(description="Winner")
    def winner(self, obj):
        if obj.winner:
            return obj.winner.short_name
        return "—"

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.select_related("tournament", "stage", "team1", "team2", "winner")


# ----- Game: one-screen data entry (stats + draft) & limit sides to series teams -----

class GameAdminForm(forms.ModelForm):
    class Meta:
        model = Game
        fields = "__all__"

    # Nice text field for MM:SS entry
    duration_display = forms.CharField(
        required=False,
        label="Duration (MM:SS)",
        help_text="Enter duration as minutes:seconds (e.g., 25:30)."
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # --- Prefill MM:SS when editing ---
        if self.instance and self.instance.duration:
            total_seconds = int(self.instance.duration.total_seconds())
            minutes, seconds = divmod(total_seconds, 60)
            self.fields["duration_display"].initial = f"{minutes:02d}:{seconds:02d}"

        # --- Limit blue/red/winner to the two series teams ---
        series = self.instance.series if (self.instance and self.instance.pk) else None
        if not series:
            sid = self.data.get("series") or self.initial.get("series")
            if sid:
                try:
                    series = Series.objects.select_related("team1", "team2").get(pk=sid)
                except Series.DoesNotExist:
                    series = None

        if series:
            teams_qs = Team.objects.filter(pk__in=[series.team1_id, series.team2_id])
            if "blue_side" in self.fields:
                self.fields["blue_side"].queryset = teams_qs
            if "red_side" in self.fields:
                self.fields["red_side"].queryset = teams_qs
            if "winner" in self.fields:
                self.fields["winner"].queryset = teams_qs
                self.fields["winner"].help_text = "Pick the winner (one of the two sides)."

        # Optional: nicer input UX
        self.fields["duration_display"].widget.attrs.update({
            "placeholder": "MM:SS",
            "pattern": r"^\d{1,3}:\d{2}$",  # up to 999:59
            "inputmode": "numeric",
        })

    def clean_duration_display(self):
        value = (self.cleaned_data.get("duration_display") or "").strip()
        if value == "":
            # Allow blank (means no duration / clear duration)
            return None
        parts = value.split(":")
        if len(parts) != 2:
            raise ValidationError("Invalid format. Use MM:SS (e.g., 23:45).")
        try:
            minutes = int(parts[0])
            seconds = int(parts[1])
        except ValueError:
            raise ValidationError("Minutes and seconds must be numbers.")
        if not (0 <= seconds <= 59):
            raise ValidationError("Seconds must be between 00 and 59.")
        return timedelta(minutes=minutes, seconds=seconds)

    def save(self, commit=True):
        """
        If duration_display provided, set instance.duration to its timedelta (or None if blank).
        If duration_display omitted entirely, leave duration as-is.
        """
        if "duration_display" in self.cleaned_data:
            self.instance.duration = self.cleaned_data["duration_display"]  # may be timedelta or None
        return super().save(commit=commit)
    

@admin.register(Game)
class GameAdmin(admin.ModelAdmin):
    form = GameAdminForm
    list_display = ("series", "game_no", "blue_side", "red_side", "formatted_duration", "winner")
    list_filter = ("series__tournament", "series__stage", "blue_side", "red_side", "result_type")
    search_fields = ("series__tournament__name", "series__team1__name", "series__team2__name")
    ordering = ("series", "game_no")
    autocomplete_fields = ("series", "blue_side", "red_side", "winner")
    readonly_fields = ("created_at", "updated_at")
    fieldsets = (
        (None, {"fields": ("series", "game_no", "blue_side", "red_side", "result_type", "duration", "vod_link")}),
        ("Results", {"fields": ("winner",)}),
        ("Timestamps", {"classes": ("collapse",), "fields": ("created_at", "updated_at")}),
    )
    inlines = [TeamGameStatInline, PlayerGameStatInline, GameDraftActionInline]

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.select_related("series", "series__tournament", "series__stage", "blue_side", "red_side", "winner")

    @admin.display(description="Duration")
    def formatted_duration(self, obj: Game):
        if not obj.duration:
            return "—"
        total_seconds = int(obj.duration.total_seconds())
        minutes, seconds = divmod(total_seconds, 60)
        return f"{minutes:02}:{seconds:02}"
         

# ----- Flat admins (if you ever open these pages directly) -----

@admin.register(TeamGameStat)
class TeamGameStatAdmin(admin.ModelAdmin):
    list_display = ("game", "team", "k", "d", "a", "turret_destroyed", "lord_kills", "turtle_kills", "game_win")
    list_filter = ("team", "game__series__tournament")
    search_fields = ("game__series__tournament__name", "team__name", "team__short_name")
    ordering = ("-game__series__scheduled_date", "team__short_name")
    autocomplete_fields = ("game", "team")
    readonly_fields = ("gold",)


@admin.register(PlayerGameStat)
class PlayerGameStatAdmin(admin.ModelAdmin):
    list_display = ("player", "team", "game", "hero", "k", "d", "a",
                    "gold", "dmg_dealt", "dmg_taken", "kda_for_list", "gpm_for_list", "dpm_for_list")
    list_filter = ("team", "hero", "player", "game__series__tournament")
    search_fields = ("player__ign", "player__name", "hero__name", "team__short_name", "team__name")
    ordering = ("-game__series__scheduled_date", "player__ign")
    autocomplete_fields = ("game", "team", "player", "hero")

    def get_queryset(self, request):
        qs = super().get_queryset(request)

        minutes = ExpressionWrapper(
            Coalesce(F('game__duration'), F("team_stat__game__duration")),
            output_field=DurationField()
        )
        return qs.annotate(
            _minutes_sec=Coalesce((F("game__duration"), F("team_stat__game__duration"))),
            _kills=Coalesce(F("k"), 0),
            _deaths=Coalesce(F("d"), 0),
            _assists=Coalesce(F("a"), 0),
            _gold=Coalesce(F("gold"), 0),
            _dmg=Coalesce(F("dmg_dealt"), 0),
        )
    
    @admin.display(description="KDA")
    def kda_for_list(self, obj):
        return f"{obj.kda_rate}"
    
    @admin.display(description="GPM")
    def gpm_for_list(self, obj):
        return f"{obj.gpm}"
    
    @admin.display(description="DPM")
    def dpm_for_list(self, obj):
        return f"{obj.dpm}"


@admin.register(GameDraftAction)
class GameDraftActionAdmin(admin.ModelAdmin):
    list_display = ("game", "order", "side", "action", "hero", "player", "team")
    list_filter = ("side", "action", "hero", "game__series__tournament")
    search_fields = ("game__series__tournament__name", "hero__name", "player__ign", "team__short_name")
    ordering = ("game", "order")
    autocomplete_fields = ("game", "hero", "player", "team")